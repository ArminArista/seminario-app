
// En este documento podríamos agregar entradas y salidas si quisieramos usar el mic de alguna manera 

function AudioSetup(){
    
    var self = this;

    self.randomNoiseNode = 0; 
    self.initAudio = 0; 
    var AudioContext = window.AudioContext || window.webkitAudioContext // esto será importante ?
    self.audioCtx = new AudioContext()

    // inicializar audio 

    self.initAudio = function (){
	 
	if (navigator.mediaDevices) {
	    navigator.mediaDevices
		.getUserMedia({ audio: true })
		.then((stream) => {
		    self.microphone = self.audioCtx.createMediaStreamSource(stream)
		    // samples()
		    // `microphone` can now act like any other AudioNode
		})
		.catch((err) => {
		    console.log(err)
		    // browser unable to access microphone
		})
	} else {
	    // browser unable to access media devices
	    // (update your browser)
	}

	self.noise();

	console.log("iniciar audio");
    }

    self.suspend = function(){
	self.audioCtx.suspend();
	console.log(" detener audio"); 
    }
    // self.initAudio(); // esto es de pruebas, puede ir afuera, el futuro quitar

    self.noise = async function(){
	await self.audioCtx.audioWorklet.addModule('js/random-noise-processor.js');
	
	self.randomNoiseNode = new AudioWorkletNode(self.audioCtx, 'random-noise-processor')
	self.gainNoise = self.randomNoiseNode.parameters.get('customGain')
	self.gainNoise.setValueAtTime(0.5, self.audioCtx.currentTime)

	// self.randomNoiseNode.connect(self.audioCtx.destination); 

	console.log("holillas"); 
    };

    self.noiseConnect = function(){
	self.randomNoiseNode.connect(self.audioCtx.destination); 
    };

   
    self.noiseDisconnect = function(){
	self.randomNoiseNode.disconnect(self.audioCtx.destination); 
    }
  
   
}

export { AudioSetup }
